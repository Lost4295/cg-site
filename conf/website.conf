server {
    listen 80;

    # MODIFICATION 1 : Le nom de domaine réel, pas 127.0.0.1
    server_name 192.168.1.2;

    root /var/www/html/public;
    index index.php index.html;

    access_log /dev/stdout;
    error_log  /dev/stderr;


    # MODIFICATION 2 : Détecter le protocole original via HAProxy
    # Si HAProxy envoie "https", Nginx met la variable $https_flag à "on"
    set $https_flag "off";
    if ($http_x_forwarded_proto = 'https') {
        set $https_flag "on";
    }

    # Fallback vers index.php
    location / {
        try_files $uri $uri/ /index.php$is_args$args;
    }

    # Let's Encrypt (au cas où HAProxy le délègue aussi)
    location ^~ /.well-known/acme-challenge/ {
        default_type text/plain;
        try_files $uri =404;
    }

    # PHP via PHP-FPM
    location ~ \.php$ {
        try_files $uri =404;
        include fastcgi_params;
         # MODIFICATION 3 : Indiquer à PHP que la connexion est HTTPS
        # Ceci corrige les problèmes de contenu mixte et de redirection.
        fastcgi_param HTTPS $https_flag;

        # MODIFICATION 4 : S'assurer que le Host est correct pour PHP
        fastcgi_param HTTP_HOST $host;

        # NOTE : Si votre conteneur PHP-FPM s'appelle "php-fpm" dans votre
        # docker-compose.yml, il vaut mieux utiliser son nom de service :
        # fastcgi_pass php-fpm:9000;
        # Si Nginx et PHP-FPM sont dans le MÊME conteneur, 127.0.0.1 est ok.
        fastcgi_pass 127.0.0.1:9000; # Ou 'php-fpm:9000'
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param DOCUMENT_ROOT   $document_root;
        fastcgi_buffers 16 16k;
        fastcgi_buffer_size 32k;
        fastcgi_read_timeout 60s;
    }

  # Protections
    location ~ /\. { deny all; }
    location ~* \.(?:ini|log|env|sql|bak|old)$ { deny all; }
}
